## 不用临时变量实现swap(a, b)
### 位运算
通过位运算实现交换，首先将a = a ^^ b，再执行第二条b = a ^^ b就可以得到b = a，但是此时a还不是了，再执行a = a ^^ b，那么a就变成b了
```objc
NSInteger a = 19;
NSInteger b = 99;

a = a ^ b;
b = a ^ b;
a = a ^ b;

// a = 99, b = 19
NSLog(@"a = %ld, b = %ld", a, b);
```
### 算术运算
实现原理：将a、b看作数轴上的两个点，利用差值来计算两者的距离并保存到其中一个变量中，再利用这个距离与a、b的差值或者和计算出交换后的a、b值：
```objc
NSInteger a = 19;
NSInteger b = 99;

// 计算a、b两者之间的距离并保存到a
a = labs(a - b);
// a、b两者之间的距离再减去b就是最初a的值，此时就交换给了b
b = labs(b - a);
// 当前的a就是最初a、b之间的距离，再加上b（也就是原来的a的值），就是b的值
// 将赋值给a就完成了a与b的交换
a = a + b;

NSLog(@"a = %ld, b = %ld", a, b);
```
这种方式也不需要借助临时变量，但是这种方式有很大的局限性，比如
a、b本是不溢出的，但是a+b后可能会溢出。
## 二维有序数组查找数字

```
[
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]

```

假设，我们查找数字34，那么我们可以这么找：

先查找第一行最后一个元素，若等于34，则查找成功；若>34，则必定就是这一行或者不存在；若<34，则说明必定是后面的行中或者根本不存在。
若第一步最后一个元素>34，则可以采用折半查找这一行。
若第一步最后一个元素<34，则说明不在第一行，则继续查找下一行最后一个元素，直到找到>34为止或者直接查找结束。
当查找到最后一个元素>34的行时，折半查找这一行即可。
时间复杂度分析：我们查找第一行最后一个元素，最坏情况下是column次，而折半查找是log2^^n
，那么最终时间复杂度为：column * log2^^n
```objc
const int rows = 3;
const int cols = 4;
int array[rows][cols] = {{1, 3, 5, 7}, {10, 11, 16, 20}, {23, 30, 34, 50}};
int searchNum = 34;
// 是否查找成功
int found = 0;

// 查找第一行最后一个元素
for (int i = 0; i < rows; ++i) {
  int last = array[i][cols - 1];

  if (last == searchNum) {
    NSLog(@"找到了，位置为：(%d, %d)", i, cols - 1);
    break;
  }
  // 说明待查找的元素就在这一行，或者根本不存在
  else if (last > searchNum) {
    int mid = 0;
    int low = 0;
    int high = cols - 1;

    while (low <= high) {
      mid = (low + high) / 2;

      if (array[i][mid] == searchNum) {
        found = YES;
        NSLog(@"找到了，位置为：(%d, %d)", i, cols - 1);
        return;
      } else if (array[i][mid] > searchNum) {
        high = mid - 1;
      } else {
        low = mid + 1;
      }
    }

    if (!found) {
      NSLog(@"查找失败了，元素并不在二维数组中");
    }
  }
}
```
## 亿级日志中，查找登陆次数最多的十个用户
假设只有一亿级日志，每条日志占用255字节，那么1亿就有1.0/4K 10000  10000 == 2500  10000M=>2.44  10000M == 24400M ~= 23.8G，可想而知是不能同时放入内存中的。
1. 我们可以通过分割成很多份，通过hash(key)对1024取模，分成1024个份，每份占用约23.8M，完全可以放内存中。
2. 然后分别对每一份操作，以登录次数作为hash的key，若key存在，则只是使key加1，若不存在则key值设置为1，只保留key值最大的10条记录，其余都丢掉（释放内存）
3. 当执行完毕后，内存中共有10 1024条记录，共10 0.25K * 1024 = 2.5M，因此内存使用上没有问题
4. 对这10 * 1024条记录排序，采用最小堆排序，或者采用红黑树（平衡二叉树）排序，提取前值最大的10条。

## 简述排序算法
* 快速排序：利用分而治之的思想，每一趟比较中保证左边的比基准数小，右边的都比基准数大。每一趟排序时，需要划分出基准数，通过partition函数来划分，得到基准后，再递归排序基准数左边的部分，递归排序基准数右边的部分。

* 堆排序：堆分为最大堆和最小堆。最大堆是每次调整堆后，保证堆顶元素是最大元素，然后将当前未有序的元素中的最后一个元素与之交换，保证右边不断有序，而左边无序元素越来越少，因此最大堆排序后是升序序列；最小堆是每次调整堆后，保证堆顶元素是最小元素，然后将当前未有序的元素中的最后一个元素与之交换，保证右边不断有序，而左边无序元素越来越少，因此最小堆排序后得到的是降序序列。

- 归并排序：采用分治法，通过将序列中分成子序列，递归归并成有序的若干个子序列，然后再二路归并成各个更大的子序列，最后再二路归并成最终序列。

<!-- - 冒泡排序：所谓冒泡，就像水中冒泡一样，将值小的不断将上浮，值大的不断往下沉。每一趟都将值最大的交换到这一趟的最后，保证待查找序列部分最后一个元素是最大值。 -->

插入排序 插入排序分为直接插入排序和折半插入排序。对于直接插入排序，每一趟都寻找a[i-1] > a[i]的，说明这时候是无序的，记录待排序值a[i]，然后将前面已有序的部分，移动位置，使a[i]值插入后，已有序部分依然有序；对于折半插入排序，每一趟都通过折半查找的方式来查找元素，然后移动位置，将之插入，使之有序，不过折半插入排序需要一个哨兵位置a[0]。
