## 简述TCP建立和关闭连接时，握手的过程。为什么前者是三次握手，后者需要四次？

TCP建立连接时，握手的过程大概如下：

- 客户端发送SYN到服务端
- 服务端发布SYN/ACK到客户端，此时开始建立连接
- 客户端发布ACK到服务端，此时正式建立好连接

客户端发送SYN到服务端，而服务端返回了客户端发过来的SYN，同时也返回ACK，那么客户端接收到之后，
就可以确定服务端收到了SYN信号，而客户端接收到服务端返回来的ACK信号后，再将ACK信号发送到服务端，
服务端就明确客户端收到了服务端发过去的信号。因此，这三次握手就可以确定了双方的身份。
TCP关闭连接时，握手的过程大致如下：
- 客户端发送FIN包到服务端：此时客户端进入FIN_WAIT_1等待对方确认状态
- 服务端返回ACK包到客户端：此时客户端结束FIN_WAIT_1状态，并进入FIN_WAIT_2状态，
等待服务端的发过来的关闭请求
- 服务端发送FIN包到客户端：此时服务端进入CLOSE_WAIT状态，等待客户端确认关闭请求
- 客户端返回ACK包到服务端：此时服务端正式关闭，结束CLOSE_WAIT状态

TCP关闭连接之所以需要四次握手，是因为TCP连接是全双工，是双向的。

## 在一个HTTPS连接的网站里，输入账号密码点击登录后，到服务器返回这个请求前，中间经历了什么

![HTTPS加密流程](http://7xs5iw.com1.z0.glb.clouddn.com/1721232-75f07ac2d2897ff2.png)
1. 客户端会打包一个请求，包括url，端口啊，你的账号密码等等。账号密码登陆应该用的是Post方式，所以相关的用户信息会被加载到body里面。这个请求应该包含三个方面：网络地址，协议，资源路径。注意，这里是HTTPS，就是HTTP + SSL / TLS，在HTTP上又加了一层处理加密信息的模块（相当于是个锁）。

2. 一般会先请求DNS服务器。DNS服务器负责将你的网络地址解析成IP地址，这个IP地址对应网上一台机器。这其中可能发生Hosts Hijack和ISP failure的问题。

3. 协议是获取资源的方式HTTP，FTP，UDP，不同协议有不同的格式，有些是process-to-process的，有些是host-to-host的。

4. 客户端会和服务器的端口之间建立一个socket连接，socket一般都是以file descriptor的方式解析请求。

5. 服务器端接收到请求。服务器端会有一套数字证书（相当于是个钥匙），这个证书会先返回给客户端。客户端会解析证书，相当于用钥匙（证书）把锁（内容）锁上（生成私匙），接着再传送加密信息。

6. 服务器端接收到加密信息（私匙）之后，会进行解密，并把要返回的数据进行对称加密返回到客户端。假如路径不对，会出现404的错误。

7. 一般访问服务器之前可能会访问一下proxy。这玩意是个代理，有时候当防火墙用，有时候当cache使。如果后台是reverse-proxy结构，那么实际上有多个web服务器藏在proxy之后按需处理请求，而你访问的永远是proxy，这样可以解决过载问题。

8. 有时候访问完web服务器后还要访问一下file服务器，主要是请求数据库里的一些信息。

9. 服务器将相应打包，直接或通过proxy（大多数时候）返回给客户端。客户端会用刚刚生成的私匙进行解密，将内容显示在浏览器上。

HTTPS加密过程详解请去https原理：[证书传递、验证和数据加密、解密过程解析](http://blog.csdn.net/clh604/article/details/22179907)

## http和scoket通信的区别
http是客户端用http协议进行请求，发送请求时候需要封装http请求头，并绑定请求的数据，
服务器一般有web服务器配合（当然也非绝对）。 http请求方式为客户端主动发起请求，服务器才能给响应，
一次请求完毕后则断开连接，以节省资源。服务器不能主动给客户端响应（除非采取http长连接 技术）。
iphone主要使用类是NSUrlConnection。

scoket是客户端跟服务器直接使用socket“套接字”进行连接，并没有规定连接后断开，
所以客户端和服务器可以保持连接通道，双方 都可以主动发送数据。一般在游戏开发或股票开发这种要求
即时性很强并且保持发送数据量比较大的场合使用。主要使用类是CFSocketRef。

## iOS中socket使用
Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，
我们才能使用TCP/IP协议。

http协议 对应于应用层
tcp协议 对应于传输层
ip协议 对应于网络层
三者本质上没有可比性。 何况HTTP协议是基于TCP连接的。

TCP/IP是传输层协议，主要解决数据如何在网络中传输；而HTTP是应用层协议，主要解决如何包装数据。

我 们在传输数据时，可以只使用传输层（TCP/IP），但是那样的话，由于没有应用层，便无法识别数据内容，
如果想要使传输的数据有意义，则必须使用应用层 协议，应用层协议很多，有HTTP、FTP、TELNET等等，
也可以自己定义应用层协议。WEB使用HTTP作传输层协议，以封装HTTP文本信息，然 后使用TCP/IP做传输层协议将它发送到网络上。

**SOCKET原理**
1. 套接字（socket）概念
套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。
它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，
本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。

应 用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。
多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，
许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，
区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。

2. 建立socket连接
建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket，另一个运行于服务器端，
称为ServerSocket。

套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。

服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，
等待客户端的连接请求。

客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，
客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，
然后就向服务器端套接字提出连接请求。

连 接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，
建立一个新的线程，把服务器端套接字的描述发给客户 端，一旦客户端确认了此描述，双方就正式建立连接。
而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。

3. SOCKET连接与TCP连接
创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），
当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。

4. Socket连接与HTTP连接
由 于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，
直到双方连接断开。但在实际网络应用 中，客户端到服务器之间的通信往往需要穿越多个中间节点，
例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，
因此需要通过轮询告诉网络，该连接处于活跃状态。

而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，
服务器端才能回复数据。

很 多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。
此时若双方建立的是Socket连接，服务器就可以直接将数据传送给 客户端；若双方建立的是HTTP连接，
则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，
不仅可以 保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。

[Socket使用简明教程－ AsyncSocket](http://my.oschina.net/joanfen/blog/287238)

### CFSocket使用有哪几个步骤。
创建 Socket 的上下文；创建 Socket ；配置要访问的服务器信息；封装服务器信息；连接服务器；
### Core Foundation中提供了哪几种操作Socket的方法？
CFNetwork 、 CFSocket 和 BSD Socket
### HTTP协议中，POST和GET的区别是什么？
1).GET 方法

GET 方法提交数据不安全，数据置于请求行，客户端地址栏可见;

GET 方法提交的数据大小有限

GET 方法不可以设置书签

2).POST 方法

POST 方法提交数据安全，数据置于消息主体内，客户端不可见

POST 方法提交的数据大小没有限制

POST 方法可以设置书签

1. GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，
参数之间以&相连，如：login.action?name=hyddd&password=idontknow&verify=%E4%BD%A0%E5%A5%BD。
如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，
得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。
　　POST把提交的数据则放置在是HTTP包的包体中。

2. ”GET方式提交的数据最多只能是1024字节，理论上POST没有限制，可传较大量的数据，IIS4中最大为80KB，IIS5中为100KB”？？！

　　以上这句是我从其他文章转过来的，其实这样说是错误的，不准确的：

　　(1).首先是”GET方式提交的数据最多只能是1024字节”，因为GET是通过URL提交数据，
那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，
HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。
IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，
其限制取决于操作系统的支持。

　　注意这是限制是整个URL长度，而不仅仅是你的参数值数据长度。[见参考资料5]

　　(2).理论上讲，POST是没有大小限制的，HTTP协议规范也没有进行大小限制，
说“POST数据量存在80K/100K的大小限制”是不准确的，POST数据是没有限制的，起限制作用的是服务器的处理程序的处理能力。

3.在ASP中，服务端获取GET请求参数用Request.QueryString，获取POST请求参数用Request.Form。
在JSP中，用request.getParameter(\”XXXX\”)来获取，虽然jsp中也有request.getQueryString()方法，
但使用起来比较麻烦，比如：传一个test.jsp?name=hyddd&password=hyddd，
用request.getQueryString()得到的是：name=hyddd&password=hyddd。在PHP中，
可以用GET和_POST分别获取GET和POST中的数据，而REQUEST则可以获取GET和POST两种请求中的数据。
值得注意的是，JSP中使用request和PHP中使用_REQUEST都会有隐患，这个下次再写个文章总结。

4.POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。
上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，
比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存，
(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，
使用GET提交数据还可能会造成Cross-site request forgery攻击。

总结一下，Get是向服务器发索取数据的一种请求，而Post是向服务器提交数据的一种请求，
在FORM（表单）中，Method默认为”GET”，实质上，GET和POST只是发送机制不同，并不是一个取一个发！

## TCP和UDP的区别
TCP全称是Transmission Control Protocol，中文名为传输控制协议，它可以提供可靠的、
面向连接的网络数据传递服务。传输控制协议主要包含下列任务和功能：

* 确保IP数据报的成功传递。

* 对程序发送的大块数据进行分段和重组。

* 确保正确排序及按顺序传递分段的数据。

* 通过计算校验和，进行传输数据的完整性检查。

TCP提供的是面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输。

简单的说，TCP注重数据安全，而UDP数据传输快点，但安全性一般

## HTTP协议及HTTPS，能否保持长连接等
HTTP协议是客户端最常用到的协议了，HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，
而且需要客户端向服务器发出请求后，服务器端才能回复数据。HTTPS是以安全为目标的HTTP通道，是HTTP的安全版。
 在HTTP下加入SSL层。 HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。
 HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，
 就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息。http的连接很简单，是无状态的，
 HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议。

Request和Response的格式：
```
// 请求
GET / HTTP/1.1

Host:xxx.xxxx.com

User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US; rv:1.9.0.10) Gecko/2016042316 Firefox/3.0.10

Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8

Accept-Language: en-us,en;q=0.5

Accept-Encoding: gzip,deflate

Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7

Keep-Alive: 300

Connection: keep-alive

If-Modified-Since: Mon, 25 May 2016 03:19:18 GMT


//响应
HTTP/1.1 200 OK

Cache-Control: private, max-age=30

Content-Type: text/html; charset=utf-8

Content-Encoding: gzip

Expires: Mon, 25 May 2016 03:20:33 GMT

Last-Modified: Mon, 25 May 2016 03:20:03 GMT

Vary: Accept-Encoding

Server: Microsoft-IIS/7.0

X-AspNet-Version: 2.0.50727

X-Powered-By: ASP.NET

Date: Mon, 25 May 2016 03:20:02 GMT

Content-Length: 12173

消息体的内容（略）
```
HTTP/1.1的默认模式使用带流水线的持久连接。这种情况下，HTTP客户每碰到一个引用就立即发出一个请求，
因而HTTP客户可以一个接一个紧挨着发出各个引用对象的请求。服务器收到这些请求后，
也可以一个接一个紧挨着发出各个对象。如果所有的请求和响应都是紧挨着发送的，
那么所有引用到的对象一共只经历1个RTT的延迟(而不是像不带流水线的版本那样，
  每个引用到的对象都各有1个RTT的延迟)。另外，带流水线的持久连接中服务器空等请求的时间比较少。
  与非持久连接相比，持久连接(不论是否带流水线)除降低了1个RTT的响应延迟外，缓启动延迟也比较小。
  其原因在于既然各个对象使用同一个TCP连接，服务器发出第一个对象后就不必再以一开始的缓慢速率发送后续对象。
  相反，服务器可以按照第一个对象发送完毕时的速率开始发送下一个对象。

参考书目：《HTTP权威指南》

## Restful架构
REST是一种架构风格，其核心是面向资源，REST专门针对网络应用设计和开发方式，以降低开发的复杂性，
提高系统的可伸缩性。REST提出设计概念和准则为：
```objc
1. 网络上的所有事物都可以被抽象为资源(resource)
2. 每一个资源都有唯一的资源标识(resource identifier)，对资源的操作不会改变这些标识
3. 所有的操作都是无状态的
```
REST简化开发，其架构遵循CRUD原则，该原则告诉我们对于资源(包括网络资源)只需要四种行为：创建，获取，
更新和删除就可以完成相关的操作和处理。
您可以通过统一资源标识符（Universal Resource Identifier，URI）来识别和定位资源，
并且针对这些资源而执行的操作是通过 HTTP 规范定义的。其核心操作只有GET,PUT,POST,DELETE。

由于REST强制所有的操作都必须是stateless的，这就没有上下文的约束，如果做分布式，
集群都不需要考虑上下文和会话保持的问题。极大的提高系统的可伸缩性。

RESTful架构：
　　（1）每一个URI代表一种资源；
　　（2）客户端和服务器之间，传递这种资源的某种表现层；
　　（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现"表现层状态转化"。

## **网络**
- UDP实现可靠传输是如何实现的
- 介绍TCP协议
- IPv4 和 IPv6 的校验和算法有什么区别？
- TCP 有一个会添加 MD5 校验和到包中的扩展。该扩展什么时候起作用？
- TCP 最小的端口号是多少?
- 描述TCP建立连接的三次握手过程？如果最后一次握手失败会怎样处理？
